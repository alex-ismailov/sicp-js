/* Упражнение 1.17.
Алгоритмы возведения в степень из этого раздела основаны на повторяющемся умножении.
Подобным же образом можно производить умножение с помощью повторяющегося сложения.
Следующая процедура умножения (в которой предполагается, что наш язык способен только
складывать, но не умножать) аналогична процедуре expt: */

const mult = (a, b) => (
  b === 0
    ? 0
    : a + mult(a, b - 1)
);

/* Этот алгоритм затрачивает количество шагов, линейно пропорциональное b.
Предположим теперь, что, наряду со сложением, у нас есть операции double,
которая удваивает целое число, и halve, которая делит (четное) число на 2.
Используя их, напишите процедуру, аналогичную fast-expt,
которая затрачивает логарифмическое число шагов. */

const isEven = (n) => n % 2 === 0;
const double = (n) => n + n;
const halve = (n) => n / 2;

const fastMult = (a, b) => {
  if (b === 0) {
    return 0;
  }
  if (b === 1) {
    return a;
  }
  return isEven(b)
    ? double(fastMult(a, halve(b)))
    : a + fastMult(a, b - 1);
};

/* testing */
console.log(fastMult(2, 5));
console.log(fastMult(2, 11));
